// Generated by `wit-bindgen-wrpc-go` 0.8.0. DO NOT EDIT!
package document

import (
	bytes "bytes"
	context "context"
	binary "encoding/binary"
	errors "errors"
	fmt "fmt"
	wasmcloud__document__types "github.com/jamesstocktonj1/mulib/provider/mongodb/gen/wasmcloud/document/types"
	io "io"
	slog "log/slog"
	math "math"
	sync "sync"
	atomic "sync/atomic"
	wrpc "wrpc.io/go"
)

type Collection = wasmcloud__document__types.Collection
type Document = wasmcloud__document__types.Document
type Filter = wasmcloud__document__types.Filter
type Handler interface {
	Insert(ctx__ context.Context, col []uint8, doc *wasmcloud__document__types.Document) (*wrpc.Result[struct{}, string], error)
	Find(ctx__ context.Context, col []uint8, filter *wasmcloud__document__types.Filter) (*wrpc.Result[[]*wasmcloud__document__types.Document, string], error)
	Update(ctx__ context.Context, col []uint8, doc *wasmcloud__document__types.Document, filter *wasmcloud__document__types.Filter) (*wrpc.Result[struct{}, string], error)
	Delete(ctx__ context.Context, col []uint8, filter *wasmcloud__document__types.Filter) (*wrpc.Result[struct{}, string], error)
}

func ServeInterface(s wrpc.Server, h Handler) (stop func() error, err error) {
	stops := make([]func() error, 0, 4)
	stop = func() error {
		for _, stop := range stops {
			if err := stop(); err != nil {
				return err
			}
		}
		return nil
	}

	stop0, err := s.Serve("wasmcloud:document/document@0.1.0-draft", "insert", func(ctx context.Context, w wrpc.IndexWriteCloser, r wrpc.IndexReadCloser) {
		defer func() {
			if err := w.Close(); err != nil {
				slog.DebugContext(ctx, "failed to close writer", "instance", "wasmcloud:document/document@0.1.0-draft", "name", "insert", "err", err)
			}
		}()
		slog.DebugContext(ctx, "reading parameter", "i", 0)
		p0, err := func() (Collection, error) {
			v, err := func(r interface {
				io.ByteReader
				io.Reader
			}) ([]byte, error) {
				var x uint32
				var s uint
				for i := 0; i < 5; i++ {
					slog.Debug("reading byte list length", "i", i)
					b, err := r.ReadByte()
					if err != nil {
						if i > 0 && err == io.EOF {
							err = io.ErrUnexpectedEOF
						}
						return nil, fmt.Errorf("failed to read byte list length byte: %w", err)
					}
					if b < 0x80 {
						if i == 4 && b > 1 {
							return nil, errors.New("byte list length overflows a 32-bit integer")
						}
						x = x | uint32(b)<<s
						buf := make([]byte, x)
						slog.Debug("reading byte list contents", "len", x)
						_, err = io.ReadFull(r, buf)
						if err != nil {
							return nil, fmt.Errorf("failed to read byte list contents: %w", err)
						}
						return buf, nil
					}
					x |= uint32(b&0x7f) << s
					s += 7
				}
				return nil, errors.New("byte length overflows a 32-bit integer")
			}(r)
			return (Collection)(v), err
		}()

		if err != nil {
			slog.WarnContext(ctx, "failed to read parameter", "i", 0, "instance", "wasmcloud:document/document@0.1.0-draft", "name", "insert", "err", err)
			if err := r.Close(); err != nil {
				slog.ErrorContext(ctx, "failed to close reader", "instance", "wasmcloud:document/document@0.1.0-draft", "name", "insert", "err", err)
			}
			return
		}
		slog.DebugContext(ctx, "reading parameter", "i", 1)
		p1, err := func() (*Document, error) {
			v, err := func(r wrpc.IndexReader, path ...uint32) (*wasmcloud__document__types.Document, error) {
				v := &wasmcloud__document__types.Document{}
				var err error
				slog.Debug("reading field", "name", "data")
				v.Data, err = func(r interface {
					io.ByteReader
					io.Reader
				}) ([]byte, error) {
					var x uint32
					var s uint
					for i := 0; i < 5; i++ {
						slog.Debug("reading byte list length", "i", i)
						b, err := r.ReadByte()
						if err != nil {
							if i > 0 && err == io.EOF {
								err = io.ErrUnexpectedEOF
							}
							return nil, fmt.Errorf("failed to read byte list length byte: %w", err)
						}
						if b < 0x80 {
							if i == 4 && b > 1 {
								return nil, errors.New("byte list length overflows a 32-bit integer")
							}
							x = x | uint32(b)<<s
							buf := make([]byte, x)
							slog.Debug("reading byte list contents", "len", x)
							_, err = io.ReadFull(r, buf)
							if err != nil {
								return nil, fmt.Errorf("failed to read byte list contents: %w", err)
							}
							return buf, nil
						}
						x |= uint32(b&0x7f) << s
						s += 7
					}
					return nil, errors.New("byte length overflows a 32-bit integer")
				}(r)
				if err != nil {
					return nil, fmt.Errorf("failed to read `data` field: %w", err)
				}
				return v, nil
			}(r, []uint32{1}...)
			return (*Document)(v), err
		}()

		if err != nil {
			slog.WarnContext(ctx, "failed to read parameter", "i", 1, "instance", "wasmcloud:document/document@0.1.0-draft", "name", "insert", "err", err)
			if err := r.Close(); err != nil {
				slog.ErrorContext(ctx, "failed to close reader", "instance", "wasmcloud:document/document@0.1.0-draft", "name", "insert", "err", err)
			}
			return
		}
		slog.DebugContext(ctx, "calling `wasmcloud:document/document@0.1.0-draft.insert` handler")
		r0, err := h.Insert(ctx, p0, p1)
		if cErr := r.Close(); cErr != nil {
			slog.ErrorContext(ctx, "failed to close reader", "instance", "wasmcloud:document/document@0.1.0-draft", "name", "insert", "err", err)
		}
		if err != nil {
			slog.WarnContext(ctx, "failed to handle invocation", "instance", "wasmcloud:document/document@0.1.0-draft", "name", "insert", "err", err)
			return
		}

		var buf bytes.Buffer
		writes := make(map[uint32]func(wrpc.IndexWriter) error, 1)

		write0, err := func(v *wrpc.Result[struct{}, string], w interface {
			io.ByteWriter
			io.Writer
		}) (func(wrpc.IndexWriter) error, error) {
			switch {
			case v.Ok == nil && v.Err == nil:
				return nil, errors.New("both result variants cannot be nil")
			case v.Ok != nil && v.Err != nil:
				return nil, errors.New("exactly one result variant must non-nil")

			case v.Ok != nil:
				slog.Debug("writing `result::ok` status byte")
				if err := w.WriteByte(0); err != nil {
					return nil, fmt.Errorf("failed to write `result::ok` status byte: %w", err)
				}
				return nil, nil
			default:
				slog.Debug("writing `result::err` status byte")
				if err := w.WriteByte(1); err != nil {
					return nil, fmt.Errorf("failed to write `result::err` status byte: %w", err)
				}
				slog.Debug("writing `result::err` payload")
				write, err := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
					n := len(v)
					if n > math.MaxUint32 {
						return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
					}
					if err = func(v int, w io.Writer) error {
						b := make([]byte, binary.MaxVarintLen32)
						i := binary.PutUvarint(b, uint64(v))
						slog.Debug("writing string byte length", "len", n)
						_, err = w.Write(b[:i])
						return err
					}(n, w); err != nil {
						return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
					}
					slog.Debug("writing string bytes")
					_, err = w.Write([]byte(v))
					if err != nil {
						return fmt.Errorf("failed to write string bytes: %w", err)
					}
					return nil
				}(*v.Err, w)
				if err != nil {
					return nil, fmt.Errorf("failed to write `result::err` payload: %w", err)
				}
				if write != nil {
					return write, nil
				}
				return nil, nil
			}
		}(r0, &buf)
		if err != nil {
			slog.WarnContext(ctx, "failed to write result value", "i", 0, "wasmcloud:document/document@0.1.0-draft", "name", "insert", "err", err)
			return
		}
		if write0 != nil {
			writes[0] = write0
		}
		slog.DebugContext(ctx, "transmitting `wasmcloud:document/document@0.1.0-draft.insert` result")
		_, err = w.Write(buf.Bytes())
		if err != nil {
			slog.WarnContext(ctx, "failed to write result", "wasmcloud:document/document@0.1.0-draft", "name", "insert", "err", err)
			return
		}
		if len(writes) > 0 {
			for index, write := range writes {
				w, err := w.Index(index)
				if err != nil {
					slog.ErrorContext(ctx, "failed to index writer", "index", index, "wasmcloud:document/document@0.1.0-draft", "name", "insert", "err", err)
					return
				}
				index := index
				write := write
				go func() {
					if err := write(w); err != nil {
						slog.WarnContext(ctx, "failed to write nested result value", "index", index, "wasmcloud:document/document@0.1.0-draft", "name", "insert", "err", err)
					}
				}()
			}
		}
	})
	if err != nil {
		return nil, fmt.Errorf("failed to serve `wasmcloud:document/document@0.1.0-draft.insert`: %w", err)
	}
	stops = append(stops, stop0)

	stop1, err := s.Serve("wasmcloud:document/document@0.1.0-draft", "find", func(ctx context.Context, w wrpc.IndexWriteCloser, r wrpc.IndexReadCloser) {
		defer func() {
			if err := w.Close(); err != nil {
				slog.DebugContext(ctx, "failed to close writer", "instance", "wasmcloud:document/document@0.1.0-draft", "name", "find", "err", err)
			}
		}()
		slog.DebugContext(ctx, "reading parameter", "i", 0)
		p0, err := func() (Collection, error) {
			v, err := func(r interface {
				io.ByteReader
				io.Reader
			}) ([]byte, error) {
				var x uint32
				var s uint
				for i := 0; i < 5; i++ {
					slog.Debug("reading byte list length", "i", i)
					b, err := r.ReadByte()
					if err != nil {
						if i > 0 && err == io.EOF {
							err = io.ErrUnexpectedEOF
						}
						return nil, fmt.Errorf("failed to read byte list length byte: %w", err)
					}
					if b < 0x80 {
						if i == 4 && b > 1 {
							return nil, errors.New("byte list length overflows a 32-bit integer")
						}
						x = x | uint32(b)<<s
						buf := make([]byte, x)
						slog.Debug("reading byte list contents", "len", x)
						_, err = io.ReadFull(r, buf)
						if err != nil {
							return nil, fmt.Errorf("failed to read byte list contents: %w", err)
						}
						return buf, nil
					}
					x |= uint32(b&0x7f) << s
					s += 7
				}
				return nil, errors.New("byte length overflows a 32-bit integer")
			}(r)
			return (Collection)(v), err
		}()

		if err != nil {
			slog.WarnContext(ctx, "failed to read parameter", "i", 0, "instance", "wasmcloud:document/document@0.1.0-draft", "name", "find", "err", err)
			if err := r.Close(); err != nil {
				slog.ErrorContext(ctx, "failed to close reader", "instance", "wasmcloud:document/document@0.1.0-draft", "name", "find", "err", err)
			}
			return
		}
		slog.DebugContext(ctx, "reading parameter", "i", 1)
		p1, err := func() (*Filter, error) {
			v, err := func(r wrpc.IndexReader, path ...uint32) (*wasmcloud__document__types.Filter, error) {
				v := &wasmcloud__document__types.Filter{}
				var err error
				slog.Debug("reading field", "name", "data")
				v.Data, err = func(r interface {
					io.ByteReader
					io.Reader
				}) ([]byte, error) {
					var x uint32
					var s uint
					for i := 0; i < 5; i++ {
						slog.Debug("reading byte list length", "i", i)
						b, err := r.ReadByte()
						if err != nil {
							if i > 0 && err == io.EOF {
								err = io.ErrUnexpectedEOF
							}
							return nil, fmt.Errorf("failed to read byte list length byte: %w", err)
						}
						if b < 0x80 {
							if i == 4 && b > 1 {
								return nil, errors.New("byte list length overflows a 32-bit integer")
							}
							x = x | uint32(b)<<s
							buf := make([]byte, x)
							slog.Debug("reading byte list contents", "len", x)
							_, err = io.ReadFull(r, buf)
							if err != nil {
								return nil, fmt.Errorf("failed to read byte list contents: %w", err)
							}
							return buf, nil
						}
						x |= uint32(b&0x7f) << s
						s += 7
					}
					return nil, errors.New("byte length overflows a 32-bit integer")
				}(r)
				if err != nil {
					return nil, fmt.Errorf("failed to read `data` field: %w", err)
				}
				return v, nil
			}(r, []uint32{1}...)
			return (*Filter)(v), err
		}()

		if err != nil {
			slog.WarnContext(ctx, "failed to read parameter", "i", 1, "instance", "wasmcloud:document/document@0.1.0-draft", "name", "find", "err", err)
			if err := r.Close(); err != nil {
				slog.ErrorContext(ctx, "failed to close reader", "instance", "wasmcloud:document/document@0.1.0-draft", "name", "find", "err", err)
			}
			return
		}
		slog.DebugContext(ctx, "calling `wasmcloud:document/document@0.1.0-draft.find` handler")
		r0, err := h.Find(ctx, p0, p1)
		if cErr := r.Close(); cErr != nil {
			slog.ErrorContext(ctx, "failed to close reader", "instance", "wasmcloud:document/document@0.1.0-draft", "name", "find", "err", err)
		}
		if err != nil {
			slog.WarnContext(ctx, "failed to handle invocation", "instance", "wasmcloud:document/document@0.1.0-draft", "name", "find", "err", err)
			return
		}

		var buf bytes.Buffer
		writes := make(map[uint32]func(wrpc.IndexWriter) error, 1)

		write0, err := func(v *wrpc.Result[[]*wasmcloud__document__types.Document, string], w interface {
			io.ByteWriter
			io.Writer
		}) (func(wrpc.IndexWriter) error, error) {
			switch {
			case v.Ok == nil && v.Err == nil:
				return nil, errors.New("both result variants cannot be nil")
			case v.Ok != nil && v.Err != nil:
				return nil, errors.New("exactly one result variant must non-nil")

			case v.Ok != nil:
				slog.Debug("writing `result::ok` status byte")
				if err := w.WriteByte(0); err != nil {
					return nil, fmt.Errorf("failed to write `result::ok` status byte: %w", err)
				}
				slog.Debug("writing `result::ok` payload")
				write, err := func(v []*wasmcloud__document__types.Document, w interface {
					io.ByteWriter
					io.Writer
				}) (write func(wrpc.IndexWriter) error, err error) {
					n := len(v)
					if n > math.MaxUint32 {
						return nil, fmt.Errorf("list length of %d overflows a 32-bit integer", n)
					}
					if err = func(v int, w io.Writer) error {
						b := make([]byte, binary.MaxVarintLen32)
						i := binary.PutUvarint(b, uint64(v))
						slog.Debug("writing list length", "len", n)
						_, err = w.Write(b[:i])
						return err
					}(n, w); err != nil {
						return nil, fmt.Errorf("failed to write list length of %d: %w", n, err)
					}
					slog.Debug("writing list elements")
					writes := make(map[uint32]func(wrpc.IndexWriter) error, n)
					for i, e := range v {
						write, err := (e).WriteToIndex(w)
						if err != nil {
							return nil, fmt.Errorf("failed to write list element %d: %w", i, err)
						}
						if write != nil {
							writes[uint32(i)] = write
						}
					}
					if len(writes) > 0 {
						return func(w wrpc.IndexWriter) error {
							var wg sync.WaitGroup
							var wgErr atomic.Value
							for index, write := range writes {
								wg.Add(1)
								w, err := w.Index(index)
								if err != nil {
									return fmt.Errorf("failed to index writer: %w", err)
								}
								write := write
								go func() {
									defer wg.Done()
									if err := write(w); err != nil {
										wgErr.Store(err)
									}
								}()
							}
							wg.Wait()
							err := wgErr.Load()
							if err == nil {
								return nil
							}
							return err.(error)
						}, nil
					}
					return nil, nil
				}(*v.Ok, w)
				if err != nil {
					return nil, fmt.Errorf("failed to write `result::ok` payload: %w", err)
				}
				if write != nil {
					return write, nil
				}
				return nil, nil
			default:
				slog.Debug("writing `result::err` status byte")
				if err := w.WriteByte(1); err != nil {
					return nil, fmt.Errorf("failed to write `result::err` status byte: %w", err)
				}
				slog.Debug("writing `result::err` payload")
				write, err := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
					n := len(v)
					if n > math.MaxUint32 {
						return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
					}
					if err = func(v int, w io.Writer) error {
						b := make([]byte, binary.MaxVarintLen32)
						i := binary.PutUvarint(b, uint64(v))
						slog.Debug("writing string byte length", "len", n)
						_, err = w.Write(b[:i])
						return err
					}(n, w); err != nil {
						return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
					}
					slog.Debug("writing string bytes")
					_, err = w.Write([]byte(v))
					if err != nil {
						return fmt.Errorf("failed to write string bytes: %w", err)
					}
					return nil
				}(*v.Err, w)
				if err != nil {
					return nil, fmt.Errorf("failed to write `result::err` payload: %w", err)
				}
				if write != nil {
					return write, nil
				}
				return nil, nil
			}
		}(r0, &buf)
		if err != nil {
			slog.WarnContext(ctx, "failed to write result value", "i", 0, "wasmcloud:document/document@0.1.0-draft", "name", "find", "err", err)
			return
		}
		if write0 != nil {
			writes[0] = write0
		}
		slog.DebugContext(ctx, "transmitting `wasmcloud:document/document@0.1.0-draft.find` result")
		_, err = w.Write(buf.Bytes())
		if err != nil {
			slog.WarnContext(ctx, "failed to write result", "wasmcloud:document/document@0.1.0-draft", "name", "find", "err", err)
			return
		}
		if len(writes) > 0 {
			for index, write := range writes {
				w, err := w.Index(index)
				if err != nil {
					slog.ErrorContext(ctx, "failed to index writer", "index", index, "wasmcloud:document/document@0.1.0-draft", "name", "find", "err", err)
					return
				}
				index := index
				write := write
				go func() {
					if err := write(w); err != nil {
						slog.WarnContext(ctx, "failed to write nested result value", "index", index, "wasmcloud:document/document@0.1.0-draft", "name", "find", "err", err)
					}
				}()
			}
		}
	})
	if err != nil {
		return nil, fmt.Errorf("failed to serve `wasmcloud:document/document@0.1.0-draft.find`: %w", err)
	}
	stops = append(stops, stop1)

	stop2, err := s.Serve("wasmcloud:document/document@0.1.0-draft", "update", func(ctx context.Context, w wrpc.IndexWriteCloser, r wrpc.IndexReadCloser) {
		defer func() {
			if err := w.Close(); err != nil {
				slog.DebugContext(ctx, "failed to close writer", "instance", "wasmcloud:document/document@0.1.0-draft", "name", "update", "err", err)
			}
		}()
		slog.DebugContext(ctx, "reading parameter", "i", 0)
		p0, err := func() (Collection, error) {
			v, err := func(r interface {
				io.ByteReader
				io.Reader
			}) ([]byte, error) {
				var x uint32
				var s uint
				for i := 0; i < 5; i++ {
					slog.Debug("reading byte list length", "i", i)
					b, err := r.ReadByte()
					if err != nil {
						if i > 0 && err == io.EOF {
							err = io.ErrUnexpectedEOF
						}
						return nil, fmt.Errorf("failed to read byte list length byte: %w", err)
					}
					if b < 0x80 {
						if i == 4 && b > 1 {
							return nil, errors.New("byte list length overflows a 32-bit integer")
						}
						x = x | uint32(b)<<s
						buf := make([]byte, x)
						slog.Debug("reading byte list contents", "len", x)
						_, err = io.ReadFull(r, buf)
						if err != nil {
							return nil, fmt.Errorf("failed to read byte list contents: %w", err)
						}
						return buf, nil
					}
					x |= uint32(b&0x7f) << s
					s += 7
				}
				return nil, errors.New("byte length overflows a 32-bit integer")
			}(r)
			return (Collection)(v), err
		}()

		if err != nil {
			slog.WarnContext(ctx, "failed to read parameter", "i", 0, "instance", "wasmcloud:document/document@0.1.0-draft", "name", "update", "err", err)
			if err := r.Close(); err != nil {
				slog.ErrorContext(ctx, "failed to close reader", "instance", "wasmcloud:document/document@0.1.0-draft", "name", "update", "err", err)
			}
			return
		}
		slog.DebugContext(ctx, "reading parameter", "i", 1)
		p1, err := func() (*Document, error) {
			v, err := func(r wrpc.IndexReader, path ...uint32) (*wasmcloud__document__types.Document, error) {
				v := &wasmcloud__document__types.Document{}
				var err error
				slog.Debug("reading field", "name", "data")
				v.Data, err = func(r interface {
					io.ByteReader
					io.Reader
				}) ([]byte, error) {
					var x uint32
					var s uint
					for i := 0; i < 5; i++ {
						slog.Debug("reading byte list length", "i", i)
						b, err := r.ReadByte()
						if err != nil {
							if i > 0 && err == io.EOF {
								err = io.ErrUnexpectedEOF
							}
							return nil, fmt.Errorf("failed to read byte list length byte: %w", err)
						}
						if b < 0x80 {
							if i == 4 && b > 1 {
								return nil, errors.New("byte list length overflows a 32-bit integer")
							}
							x = x | uint32(b)<<s
							buf := make([]byte, x)
							slog.Debug("reading byte list contents", "len", x)
							_, err = io.ReadFull(r, buf)
							if err != nil {
								return nil, fmt.Errorf("failed to read byte list contents: %w", err)
							}
							return buf, nil
						}
						x |= uint32(b&0x7f) << s
						s += 7
					}
					return nil, errors.New("byte length overflows a 32-bit integer")
				}(r)
				if err != nil {
					return nil, fmt.Errorf("failed to read `data` field: %w", err)
				}
				return v, nil
			}(r, []uint32{1}...)
			return (*Document)(v), err
		}()

		if err != nil {
			slog.WarnContext(ctx, "failed to read parameter", "i", 1, "instance", "wasmcloud:document/document@0.1.0-draft", "name", "update", "err", err)
			if err := r.Close(); err != nil {
				slog.ErrorContext(ctx, "failed to close reader", "instance", "wasmcloud:document/document@0.1.0-draft", "name", "update", "err", err)
			}
			return
		}
		slog.DebugContext(ctx, "reading parameter", "i", 2)
		p2, err := func() (*Filter, error) {
			v, err := func(r wrpc.IndexReader, path ...uint32) (*wasmcloud__document__types.Filter, error) {
				v := &wasmcloud__document__types.Filter{}
				var err error
				slog.Debug("reading field", "name", "data")
				v.Data, err = func(r interface {
					io.ByteReader
					io.Reader
				}) ([]byte, error) {
					var x uint32
					var s uint
					for i := 0; i < 5; i++ {
						slog.Debug("reading byte list length", "i", i)
						b, err := r.ReadByte()
						if err != nil {
							if i > 0 && err == io.EOF {
								err = io.ErrUnexpectedEOF
							}
							return nil, fmt.Errorf("failed to read byte list length byte: %w", err)
						}
						if b < 0x80 {
							if i == 4 && b > 1 {
								return nil, errors.New("byte list length overflows a 32-bit integer")
							}
							x = x | uint32(b)<<s
							buf := make([]byte, x)
							slog.Debug("reading byte list contents", "len", x)
							_, err = io.ReadFull(r, buf)
							if err != nil {
								return nil, fmt.Errorf("failed to read byte list contents: %w", err)
							}
							return buf, nil
						}
						x |= uint32(b&0x7f) << s
						s += 7
					}
					return nil, errors.New("byte length overflows a 32-bit integer")
				}(r)
				if err != nil {
					return nil, fmt.Errorf("failed to read `data` field: %w", err)
				}
				return v, nil
			}(r, []uint32{2}...)
			return (*Filter)(v), err
		}()

		if err != nil {
			slog.WarnContext(ctx, "failed to read parameter", "i", 2, "instance", "wasmcloud:document/document@0.1.0-draft", "name", "update", "err", err)
			if err := r.Close(); err != nil {
				slog.ErrorContext(ctx, "failed to close reader", "instance", "wasmcloud:document/document@0.1.0-draft", "name", "update", "err", err)
			}
			return
		}
		slog.DebugContext(ctx, "calling `wasmcloud:document/document@0.1.0-draft.update` handler")
		r0, err := h.Update(ctx, p0, p1, p2)
		if cErr := r.Close(); cErr != nil {
			slog.ErrorContext(ctx, "failed to close reader", "instance", "wasmcloud:document/document@0.1.0-draft", "name", "update", "err", err)
		}
		if err != nil {
			slog.WarnContext(ctx, "failed to handle invocation", "instance", "wasmcloud:document/document@0.1.0-draft", "name", "update", "err", err)
			return
		}

		var buf bytes.Buffer
		writes := make(map[uint32]func(wrpc.IndexWriter) error, 1)

		write0, err := func(v *wrpc.Result[struct{}, string], w interface {
			io.ByteWriter
			io.Writer
		}) (func(wrpc.IndexWriter) error, error) {
			switch {
			case v.Ok == nil && v.Err == nil:
				return nil, errors.New("both result variants cannot be nil")
			case v.Ok != nil && v.Err != nil:
				return nil, errors.New("exactly one result variant must non-nil")

			case v.Ok != nil:
				slog.Debug("writing `result::ok` status byte")
				if err := w.WriteByte(0); err != nil {
					return nil, fmt.Errorf("failed to write `result::ok` status byte: %w", err)
				}
				return nil, nil
			default:
				slog.Debug("writing `result::err` status byte")
				if err := w.WriteByte(1); err != nil {
					return nil, fmt.Errorf("failed to write `result::err` status byte: %w", err)
				}
				slog.Debug("writing `result::err` payload")
				write, err := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
					n := len(v)
					if n > math.MaxUint32 {
						return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
					}
					if err = func(v int, w io.Writer) error {
						b := make([]byte, binary.MaxVarintLen32)
						i := binary.PutUvarint(b, uint64(v))
						slog.Debug("writing string byte length", "len", n)
						_, err = w.Write(b[:i])
						return err
					}(n, w); err != nil {
						return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
					}
					slog.Debug("writing string bytes")
					_, err = w.Write([]byte(v))
					if err != nil {
						return fmt.Errorf("failed to write string bytes: %w", err)
					}
					return nil
				}(*v.Err, w)
				if err != nil {
					return nil, fmt.Errorf("failed to write `result::err` payload: %w", err)
				}
				if write != nil {
					return write, nil
				}
				return nil, nil
			}
		}(r0, &buf)
		if err != nil {
			slog.WarnContext(ctx, "failed to write result value", "i", 0, "wasmcloud:document/document@0.1.0-draft", "name", "update", "err", err)
			return
		}
		if write0 != nil {
			writes[0] = write0
		}
		slog.DebugContext(ctx, "transmitting `wasmcloud:document/document@0.1.0-draft.update` result")
		_, err = w.Write(buf.Bytes())
		if err != nil {
			slog.WarnContext(ctx, "failed to write result", "wasmcloud:document/document@0.1.0-draft", "name", "update", "err", err)
			return
		}
		if len(writes) > 0 {
			for index, write := range writes {
				w, err := w.Index(index)
				if err != nil {
					slog.ErrorContext(ctx, "failed to index writer", "index", index, "wasmcloud:document/document@0.1.0-draft", "name", "update", "err", err)
					return
				}
				index := index
				write := write
				go func() {
					if err := write(w); err != nil {
						slog.WarnContext(ctx, "failed to write nested result value", "index", index, "wasmcloud:document/document@0.1.0-draft", "name", "update", "err", err)
					}
				}()
			}
		}
	})
	if err != nil {
		return nil, fmt.Errorf("failed to serve `wasmcloud:document/document@0.1.0-draft.update`: %w", err)
	}
	stops = append(stops, stop2)

	stop3, err := s.Serve("wasmcloud:document/document@0.1.0-draft", "delete", func(ctx context.Context, w wrpc.IndexWriteCloser, r wrpc.IndexReadCloser) {
		defer func() {
			if err := w.Close(); err != nil {
				slog.DebugContext(ctx, "failed to close writer", "instance", "wasmcloud:document/document@0.1.0-draft", "name", "delete", "err", err)
			}
		}()
		slog.DebugContext(ctx, "reading parameter", "i", 0)
		p0, err := func() (Collection, error) {
			v, err := func(r interface {
				io.ByteReader
				io.Reader
			}) ([]byte, error) {
				var x uint32
				var s uint
				for i := 0; i < 5; i++ {
					slog.Debug("reading byte list length", "i", i)
					b, err := r.ReadByte()
					if err != nil {
						if i > 0 && err == io.EOF {
							err = io.ErrUnexpectedEOF
						}
						return nil, fmt.Errorf("failed to read byte list length byte: %w", err)
					}
					if b < 0x80 {
						if i == 4 && b > 1 {
							return nil, errors.New("byte list length overflows a 32-bit integer")
						}
						x = x | uint32(b)<<s
						buf := make([]byte, x)
						slog.Debug("reading byte list contents", "len", x)
						_, err = io.ReadFull(r, buf)
						if err != nil {
							return nil, fmt.Errorf("failed to read byte list contents: %w", err)
						}
						return buf, nil
					}
					x |= uint32(b&0x7f) << s
					s += 7
				}
				return nil, errors.New("byte length overflows a 32-bit integer")
			}(r)
			return (Collection)(v), err
		}()

		if err != nil {
			slog.WarnContext(ctx, "failed to read parameter", "i", 0, "instance", "wasmcloud:document/document@0.1.0-draft", "name", "delete", "err", err)
			if err := r.Close(); err != nil {
				slog.ErrorContext(ctx, "failed to close reader", "instance", "wasmcloud:document/document@0.1.0-draft", "name", "delete", "err", err)
			}
			return
		}
		slog.DebugContext(ctx, "reading parameter", "i", 1)
		p1, err := func() (*Filter, error) {
			v, err := func(r wrpc.IndexReader, path ...uint32) (*wasmcloud__document__types.Filter, error) {
				v := &wasmcloud__document__types.Filter{}
				var err error
				slog.Debug("reading field", "name", "data")
				v.Data, err = func(r interface {
					io.ByteReader
					io.Reader
				}) ([]byte, error) {
					var x uint32
					var s uint
					for i := 0; i < 5; i++ {
						slog.Debug("reading byte list length", "i", i)
						b, err := r.ReadByte()
						if err != nil {
							if i > 0 && err == io.EOF {
								err = io.ErrUnexpectedEOF
							}
							return nil, fmt.Errorf("failed to read byte list length byte: %w", err)
						}
						if b < 0x80 {
							if i == 4 && b > 1 {
								return nil, errors.New("byte list length overflows a 32-bit integer")
							}
							x = x | uint32(b)<<s
							buf := make([]byte, x)
							slog.Debug("reading byte list contents", "len", x)
							_, err = io.ReadFull(r, buf)
							if err != nil {
								return nil, fmt.Errorf("failed to read byte list contents: %w", err)
							}
							return buf, nil
						}
						x |= uint32(b&0x7f) << s
						s += 7
					}
					return nil, errors.New("byte length overflows a 32-bit integer")
				}(r)
				if err != nil {
					return nil, fmt.Errorf("failed to read `data` field: %w", err)
				}
				return v, nil
			}(r, []uint32{1}...)
			return (*Filter)(v), err
		}()

		if err != nil {
			slog.WarnContext(ctx, "failed to read parameter", "i", 1, "instance", "wasmcloud:document/document@0.1.0-draft", "name", "delete", "err", err)
			if err := r.Close(); err != nil {
				slog.ErrorContext(ctx, "failed to close reader", "instance", "wasmcloud:document/document@0.1.0-draft", "name", "delete", "err", err)
			}
			return
		}
		slog.DebugContext(ctx, "calling `wasmcloud:document/document@0.1.0-draft.delete` handler")
		r0, err := h.Delete(ctx, p0, p1)
		if cErr := r.Close(); cErr != nil {
			slog.ErrorContext(ctx, "failed to close reader", "instance", "wasmcloud:document/document@0.1.0-draft", "name", "delete", "err", err)
		}
		if err != nil {
			slog.WarnContext(ctx, "failed to handle invocation", "instance", "wasmcloud:document/document@0.1.0-draft", "name", "delete", "err", err)
			return
		}

		var buf bytes.Buffer
		writes := make(map[uint32]func(wrpc.IndexWriter) error, 1)

		write0, err := func(v *wrpc.Result[struct{}, string], w interface {
			io.ByteWriter
			io.Writer
		}) (func(wrpc.IndexWriter) error, error) {
			switch {
			case v.Ok == nil && v.Err == nil:
				return nil, errors.New("both result variants cannot be nil")
			case v.Ok != nil && v.Err != nil:
				return nil, errors.New("exactly one result variant must non-nil")

			case v.Ok != nil:
				slog.Debug("writing `result::ok` status byte")
				if err := w.WriteByte(0); err != nil {
					return nil, fmt.Errorf("failed to write `result::ok` status byte: %w", err)
				}
				return nil, nil
			default:
				slog.Debug("writing `result::err` status byte")
				if err := w.WriteByte(1); err != nil {
					return nil, fmt.Errorf("failed to write `result::err` status byte: %w", err)
				}
				slog.Debug("writing `result::err` payload")
				write, err := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
					n := len(v)
					if n > math.MaxUint32 {
						return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
					}
					if err = func(v int, w io.Writer) error {
						b := make([]byte, binary.MaxVarintLen32)
						i := binary.PutUvarint(b, uint64(v))
						slog.Debug("writing string byte length", "len", n)
						_, err = w.Write(b[:i])
						return err
					}(n, w); err != nil {
						return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
					}
					slog.Debug("writing string bytes")
					_, err = w.Write([]byte(v))
					if err != nil {
						return fmt.Errorf("failed to write string bytes: %w", err)
					}
					return nil
				}(*v.Err, w)
				if err != nil {
					return nil, fmt.Errorf("failed to write `result::err` payload: %w", err)
				}
				if write != nil {
					return write, nil
				}
				return nil, nil
			}
		}(r0, &buf)
		if err != nil {
			slog.WarnContext(ctx, "failed to write result value", "i", 0, "wasmcloud:document/document@0.1.0-draft", "name", "delete", "err", err)
			return
		}
		if write0 != nil {
			writes[0] = write0
		}
		slog.DebugContext(ctx, "transmitting `wasmcloud:document/document@0.1.0-draft.delete` result")
		_, err = w.Write(buf.Bytes())
		if err != nil {
			slog.WarnContext(ctx, "failed to write result", "wasmcloud:document/document@0.1.0-draft", "name", "delete", "err", err)
			return
		}
		if len(writes) > 0 {
			for index, write := range writes {
				w, err := w.Index(index)
				if err != nil {
					slog.ErrorContext(ctx, "failed to index writer", "index", index, "wasmcloud:document/document@0.1.0-draft", "name", "delete", "err", err)
					return
				}
				index := index
				write := write
				go func() {
					if err := write(w); err != nil {
						slog.WarnContext(ctx, "failed to write nested result value", "index", index, "wasmcloud:document/document@0.1.0-draft", "name", "delete", "err", err)
					}
				}()
			}
		}
	})
	if err != nil {
		return nil, fmt.Errorf("failed to serve `wasmcloud:document/document@0.1.0-draft.delete`: %w", err)
	}
	stops = append(stops, stop3)
	return stop, nil
}
